---
title: "STATISTCAL ARBITRAGE TRADING"
format: html
editor: visual
---

```{r}
#| message: false
#| warning: false
#| include: false
# IPORTING NECESSARY LIBRARIES
library(quantmod)
library(tidyverse)
library(patchwork)
library(corrplot)
library(factoextra)
library(FactoMineR)
library(RColorBrewer)
library(reshape2)
library(xts)
library(zoo)
library(tseries)
library(changepoint)
library(lubridate)
library(car)
library(tseries)
library(urca)
library(CADFtest)
library(MASS)
library(Rmixmod)
library(mclust)
library(depmixS4)
library(ggplot2)
library(gridExtra)
library(scales)
library(PerformanceAnalytics)
```

```{r}
bank <-c("HDFCBANK.NS", "ICICIBANK.NS", "SBIN.NS", "KOTAKBANK.NS", "AXISBANK.NS", 
"BANKBARODA.NS", "PNB.NS", "CANBK.NS", "INDUSINDBK.NS", "AUBANK.NS","IDFCFIRSTB.NS", "FEDERALBNK.NS")


tech <- c("HCLTECH.NS", "INFY.NS", "MPHASIS.NS", "PERSISTENT.NS",  "TCS.NS",
  "TECHM.NS",  "WIPRO.NS",  "COFORGE.NS",  "LTIM.NS",  "LTTS.NS")

pharma <- c("ABBOTINDIA.NS", "AJANTPHARM.NS", "ALKEM.NS", "AUROPHARMA.NS",
  "BIOCON.NS", "CIPLA.NS", "DIVISLAB.NS", "DRREDDY.NS", "GLAND.NS", "GLENMARK.NS",
  "GRANULES.NS", "IPCALAB.NS", "JBCHEPHARM.NS", "LAURUSLABS.NS", "LUPIN.NS",
  "MANKIND.NS", "NATCOPHARM.NS", "SUNPHARMA.NS", "TORNTPHARM.NS", "ZYDUSLIFE.NS")

auto <- c("M&M.NS", "MARUTI.NS", "TATAMOTORS.NS", "BAJAJ-AUTO.NS", 
  "EICHERMOT.NS", "TVSMOTOR.NS", "BOSCHLTD.NS", "MOTHERSON.NS", "HEROMOTOCO.NS",
  "ASHOKLEY.NS", "MRF.NS", "TIINDIA.NS", "BHARATFORG.NS", "BALKRISIND.NS", 
  "EXIDEIND.NS")

energy <- c("RELIANCE.NS", "NTPC.NS", "ONGC.NS", "POWERGRID.NS", "COALINDIA.NS",   
  "ADANIPOWER.NS", "IOC.NS", "ADANIGREEN.NS", "BPCL.NS", "TATAPOWER.NS",    
  "GAIL.NS", "SIEMENS.NS", "ABB.NS", "CGPOWER.NS", "ADANIENSOL.NS",    
  "JSWENERGY.NS", "HITACHI.NS", "HINDPETRO.NS", "SUZLON.NS", "NHPC.NS",        
  "BHEL.NS", "GEPOWER.NS", "OIL.NS", "TORNTPOWER.NS", "ATGL.NS", "PETRONET.NS",       "THERMAX.NS", "SJVN.NS", "NLCINDIA.NS", "GUJGASLTD.NS", "IGL.NS","AEGISCHEM.NS",   "INOXWIND.NS", "CESC.NS", "CASTROLIND.NS", "RPOWER.NS", "GSPL.NS","TRITURBINE.NS", "JPPOWER.NS", "MGL.NS")

```

```{r}
# TAKING THE INPUTS
startdate<-"2021-01-01"
enddate<- Sys.Date()
#TICKER INPUT OF SYMBOL
tickers<- energy
```

```{r}
# CREATING FUNCTION TO IMPORT PRICES AND RETURNS DATA
get_data <- function(tickers, start, end) {
  price_list <- list()
  return_list <- list()
  for (ticker in tickers) {
    tryCatch({
      data <- getSymbols(ticker, from = start, to = end, auto.assign = FALSE)
      adj_price <- Ad(data)
      daily_ret <- dailyReturn(adj_price, type = "arithmetic")
      clean_name <- sub("\\..*$", "", ticker)
      colnames(adj_price) <- clean_name
      colnames(daily_ret) <- clean_name
      price_list[[clean_name]] <- adj_price
      return_list[[clean_name]] <- daily_ret
    }, error = function(e) {
      cat("Error with", ticker, ":", e$message, "\n")
    })
  }
  prices <- do.call(merge, price_list)
  returns <- do.call(merge, return_list)
  return(list(prices = prices, returns = returns))
}
```

```{r}
#EXTRACTING THE DATA
stock_data <- get_data(tickers, startdate, enddate)
price_df <- na.omit(data.frame(date = index(stock_data$prices), stock_data$prices))
return_df <- na.omit(data.frame(date = index(stock_data$returns), stock_data$returns))
```

```{r}
# APPLYING PRINCIPAL COMPONENT ANALYSIS

pca <- PCA(return_df[-1,-1], scale.unit = TRUE, graph = FALSE, 
           ncp = ncol(return_df))

eigenvalues <- pca$eig[, 1]

variance_explained <- pca$eig[, 2]

cumulative_variance <- pca$eig[, 3]

eigenvalues_df <- data.frame(
  PC = factor(paste0("PC", seq_along(eigenvalues)), levels = paste0("PC", seq_along(eigenvalues))),
  Eigenvalue = eigenvalues,
  VarianceExplained = variance_explained,
  CumulativeVariance = cumulative_variance
)
```

```{r}
#| warning: false
eig_plot <- ggplot(eigenvalues_df, aes(x = PC, y = Eigenvalue, group = 1)) +
  geom_bar(stat = "identity", fill = "skyblue", alpha = 0.8) +
  geom_line(color = "blue", size = 1.2) +
  geom_point(color = "red", size = 2) +
  labs(title = "Scree Plot - Eigenvalues from PCA",
       x = "Principal Components",
       y = "Eigenvalue") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
var_plot<- ggplot(eigenvalues_df, aes(x = PC)) +
  geom_bar(aes(y = VarianceExplained), stat = "identity", fill = "skyblue", alpha = 0.6) +
  labs(title = "Variance Explained by Component",
       x = "Principal Components",
       y = "Percentage (%)") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
pca_plots <- eig_plot / var_plot
pca_plots
```

```{r}
eigenvalues_df
```

```{r}
#FUNCTION TO GET PLOTS OF EIGENVECTORS
eigvec_plot <- function(pca, n){
  eigvec <- as.data.frame(pca$var$coord)
  my_colors <- rainbow(length(eigvec$Dim.1))
  plot<- barplot(eigvec[,n], col = my_colors, 
                          main = paste("WEIGTHS OF PRINCIPAL COMPONENT",n,sep = " "),
                          ylab = "Weights", las = 2,names.arg = rownames(eigvec))
  
  return(plot)
}
```

```{r}
#FUNCTION TO GET ROLLING EXPLAINED VARIANCE PLOT OF iTH PC
pcvar_plot <- function(df, n, t) {
  df_dates <- as.Date(df[[1]])
  df_returns <- df[-1, -1]
  d1 <- data.frame(Date = as.Date(character()), ExpVar = numeric())
  for (i in 1:(nrow(df_returns) - t)) {
    j <- i + t
    k <- round((i + j) / 2) 
    window_data <- df_returns[i:j, ]
    pca_temp <- prcomp(window_data, center = TRUE, scale. = TRUE)
    exp_var <- pca_temp$sdev[n]^2 / sum(pca_temp$sdev^2)
    d1 <- rbind(d1, data.frame(Date = df_dates[k], ExpVar = exp_var))
  }
  ggplot(d1, aes(x = Date, y = ExpVar)) +
    geom_line(color = "darkblue", size = 1) +
    labs(title = paste("Rolling Explained Variance of PC", n),
         x = "Date", y = "Explained Variance") +
    theme_minimal() + theme(plot.title = element_text(hjust = 0.5),
          axis.text.x = element_text(angle = 45, hjust = 1))
}

```

```{r}
#| fig-height: 8
#| fig-width: 10
p1 <-   eigvec_plot(pca, 1) 
p2 <-   eigvec_plot(pca, 2)
p3 <-   eigvec_plot(pca, 3)
p4 <-   eigvec_plot(pca, 4)
p5 <-   eigvec_plot(pca, 5)
p6 <-   eigvec_plot(pca, 6)
```

```{r}
pcvar_plot(return_df,1, 120)
```

```{r}
library(MASS)
library(car)

names <- colnames(return_df[, -1])
components <- as.data.frame(pca$ind$coord)[, 1:4]

avplots_list <- list()
coeff_df <- data.frame()

for (i in names) {
  reg_data <- cbind(return_df[-1, i, drop = FALSE], components)
  colnames(reg_data)[1] <- "target"

  po <- rlm(target ~ ., data = reg_data)

  # Store AV plot
  avPlots(po, main = paste("AV Plots:", i))
  avplots_list[[i]] <- recordPlot()

  # Get coefficients, fill NAs if needed
  coefs <- coef(po)
  coeff_row <- as.data.frame(t(coefs))
  coeff_row$stock <- i

  # Bind row to main dataframe
  coeff_df <- rbind(coeff_df, coeff_row)
}


```

```{r}
coeff_df
```

```{r}
str(return_df)
```

```{r}
# Store original row count
n_original <- nrow(return_df)

# Columns without 'date'
stock_cols <- setdiff(names(return_df), "date")

# Market return = mean of all stocks
return_df$market <- rowMeans(return_df[stock_cols], na.rm = TRUE)

# Rolling 21-day market volatility
return_df$rolling_vol <- rollapply(return_df$market, 21, sd, na.rm = TRUE, 
                                   fill = NA, align = "right")

# Dispersion: cross-sectional volatility / mean magnitude
return_df$vol_dispersion <- apply(return_df[stock_cols], 1, \(row) {
  mean_abs <- mean(abs(row), na.rm = TRUE)
  if (mean_abs < 1e-10) return(0)
  sd(row, na.rm = TRUE) / mean_abs
})

# Fill NA rolling vol, remove incomplete rows
return_df$rolling_vol <- na.locf(return_df$rolling_vol, na.rm = FALSE)
return_df <- na.omit(return_df)

# Report removed rows
cat("Removed", n_original - nrow(return_df), "rows with missing values\n")

```

```{r}

stock_cols <- names(return_df)[!names(return_df) %in% 
                               c("date", "market", "rolling_vol", "vol_dispersion")]

stock_returns <- return_df[, stock_cols]
stock_returns[is.na(stock_returns)] <- 0
scaled_returns <- scale(stock_returns)
pca_result <- PCA(scaled_returns, graph = FALSE, ncp = 10)
eigenvalues <- pca_result$eig
n_components <- sum(eigenvalues[,1] > 1) 
n_components <- min(max(n_components, 4), 6)
pc_scores <- as.data.frame(pca_result$ind$coord[, 1:n_components])
colnames(pc_scores) <- paste0("PC", 1:n_components)
return_df <- cbind(return_df, pc_scores)
```

```{r}
# 1. Get PCA columns
pc_data <- return_df[grep("^PC\\d+$", names(return_df))]
gmm_test <- Mclust(pc_data, G = 2:6)
```

```{r}
plot(gmm_test, what = "BIC")
gmm_test$BIC
```

```{r}
fit_regime_model <- function(pc_data, G_range = 1:9, 
model_names = c("EII", "VII", "EEI", "VEI", "EVI", "VVI", "EEE", "EEV", "VEV", "VVV"), shrinkage = NULL, auto_select = TRUE) {
  require(mclust)
  set.seed(123)  # Critical for reproducibility
  
  # Auto-select optimal parameters via BIC
  if (auto_select) {
    cat("Performing Bayesian model selection...\n")
    
    # Initialize optimization trackers
    best_bic <- -Inf
    best_model <- NULL
    shrinkage_grid <- if(is.null(shrinkage)) seq(0.05, 1, 0.05) else shrinkage
    
    for (sh in shrinkage_grid) {
      gmm_candidate <- Mclust(
        pc_data, 
        G = G_range,
        modelNames = model_names,
        prior = priorControl(shrinkage = sh),
        verbose = FALSE
      )
      
      # Validate and compare models
      if (!is.null(gmm_candidate) && 
          !is.na(gmm_candidate$bic) && 
          (gmm_candidate$bic > best_bic)) {
        best_model <- gmm_candidate
        best_bic <- gmm_candidate$bic
        optimal_sh <- sh
      }
    }
    
    if (is.null(best_model)) stop("Model convergence failed. Check data quality.")
    
    # Build final model report
    model_report <- list(
      model = best_model,
      shrinkage = optimal_sh,
      G = best_model$G,
      modelName = best_model$modelName,
      BIC = best_model$bic
    )
    
    cat("Optimal model selected:\n")
    cat("  Clusters (G):     ", model_report$G, "\n")
    cat("  Covariance:       ", model_report$modelName, "\n")
    cat("  Shrinkage:        ", round(model_report$shrinkage, 3), "\n")
    cat("  BIC:              ", round(model_report$BIC, 2), "\n")
    
    return(model_report)
  } 
  
  # Manual parameter specification
  else {
    if (is.null(shrinkage)) stop("Shrinkage must be specified for manual mode")
    if (length(G_range) > 1) warning("Using first G value for manual mode: ", G_range[1])
    
    cat("Fitting manual specification model...\n")
    manual_model <- Mclust(
      pc_data,
      G = G_range[1],
      modelNames = model_names,
      prior = priorControl(shrinkage = shrinkage),
      verbose = FALSE
    )
    
    if (is.null(manual_model)) stop("Manual model failed to converge.")
    
    return(list(
      model = manual_model,
      shrinkage = shrinkage,
      G = G_range[1],
      modelName = model_names[1],  # First specified
      BIC = manual_model$bic
    ))
  }
}

# ========================
# REGIME ASSIGNMENT MODULE
# ========================
assign_regimes <- function(model_object, return_df) {
  # Assign classifications and probabilities
  return_df$regime <- model_object$model$classification
  return_df$regime_prob <- apply(model_object$model$z, 1, max)
  
  # Calculate regime diagnostics
  regime_stats <- return_df %>%
    group_by(regime) %>%
    summarise(
      n_obs = n(),
      mean_return = mean(market, na.rm = TRUE),
      vol = sd(market, na.rm = TRUE),
      sharpe = mean_return / vol
    )
  
  cat("\nRegime Characteristics:\n")
  print(regime_stats)
  
  return(return_df)
}

# ======================
# EXECUTION EXAMPLES
# ======================


```

```{r}
# Example 1: Auto-select optimal model
optimal_model <- fit_regime_model(pc_data, auto_select = TRUE)
return_df <- assign_regimes(optimal_model, return_df)

# Example 2: Manual specification
#manual_model <- fit_regime_model(pc_data, G_range = 4, model_names = "VEI",shrinkage = 0.05, auto_select = FALSE)
#return_df <- assign_regimes(manual_model, return_df)

# Example 3: Markov transition analysis
if (length(unique(return_df$regime)) > 1) {
  require(markovchain)
  mc_fit <- markovchainFit(return_df$regime)
  cat("\nMarkov Transition Probabilities:\n")
  print(mc_fit$estimate)
}
```

```{r}

plot1 <- ggplot(return_df, aes(x = date, y = market, color = factor(regime))) +
  geom_line() +
  labs(title = "Market Return with Regimes", color = "Regime") +
  theme_minimal()

plot2<- ggplot(return_df, aes(market, fill = factor(regime))) +
  geom_histogram(alpha = 0.3, bins = 30) +
  facet_wrap(~ regime, scales = "free_y") +
  labs(title = "Market Return by Regime", fill = "Regime") +
  theme_minimal()

wrap_plots(list(plot1, plot2), ncol=1)
```

```{r}
# Boxplots for volatility and dispersion
 ggplot(return_df, aes(x = factor(regime), y = market)) +
  geom_boxplot() + labs(title="Market Return by Regime", x="Regime", y="Market Return")

 ggplot(return_df, aes(x = factor(regime), y = rolling_vol)) +
  geom_boxplot() + labs(title="21-day Volatility by Regime", x="Regime", y="Volatility")

```

```{r}
# Transition matrix calculation
transition_counts <- table(
  from = head(return_df$regime, -1),
  to   = tail(return_df$regime, -1)
)

transition_matrix <- prop.table(transition_counts, margin = 1)
print(transition_matrix)

# Visualize transitions as heatmap
transition_df <- as.data.frame(as.table(transition_matrix))
colnames(transition_df) <- c("From", "To", "Probability")

ggplot(transition_df, aes(x = From, y = To, fill = Probability)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(Probability, 2)), color = "black") +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Regime Transition Probability Matrix",
       x = "From Regime", y = "To Regime") +
  theme_minimal()
```
