---
title: "STATISTCAL ARBITRAGE TRADING"
format: html
editor: visual
---

```{r}
#| message: false
#| warning: false
#| include: false
# IPORTING NECESSARY LIBRARIES
library(quantmod)
library(tidyverse)
library(patchwork)
library(corrplot)
library(factoextra)
library(FactoMineR)
library(RColorBrewer)
library(reshape2)
library(xts)
library(zoo)
library(tseries)
library(changepoint)
library(lubridate)
library(car)
library(tseries)
library(urca)
library(CADFtest)
library(MASS)
library(Rmixmod)
library(mclust)
library(depmixS4)
library(ggplot2)
library(gridExtra)
library(scales)
library(PerformanceAnalytics)
```

### Creating the tickers

```{r}
bank <-c("HDFCBANK.NS", "ICICIBANK.NS", "SBIN.NS", "KOTAKBANK.NS", "AXISBANK.NS", 
"BANKBARODA.NS", "PNB.NS", "CANBK.NS", "INDUSINDBK.NS", "AUBANK.NS","IDFCFIRSTB.NS", "FEDERALBNK.NS")


tech <- c("HCLTECH.NS", "INFY.NS", "MPHASIS.NS", "PERSISTENT.NS",  "TCS.NS",
  "TECHM.NS",  "WIPRO.NS",  "COFORGE.NS",  "LTIM.NS",  "LTTS.NS")

pharma <- c("ABBOTINDIA.NS", "AJANTPHARM.NS", "ALKEM.NS", "AUROPHARMA.NS",
  "BIOCON.NS", "CIPLA.NS", "DIVISLAB.NS", "DRREDDY.NS", "GLAND.NS", "GLENMARK.NS",
  "GRANULES.NS", "IPCALAB.NS", "JBCHEPHARM.NS", "LAURUSLABS.NS", "LUPIN.NS",
  "MANKIND.NS", "NATCOPHARM.NS", "SUNPHARMA.NS", "TORNTPHARM.NS", "ZYDUSLIFE.NS")

auto <- c("M&M.NS", "MARUTI.NS", "TATAMOTORS.NS", "BAJAJ-AUTO.NS", 
  "EICHERMOT.NS", "TVSMOTOR.NS", "BOSCHLTD.NS", "MOTHERSON.NS", "HEROMOTOCO.NS",
  "ASHOKLEY.NS", "MRF.NS", "TIINDIA.NS", "BHARATFORG.NS", "BALKRISIND.NS", 
  "EXIDEIND.NS")

energy <- c("RELIANCE.NS", "NTPC.NS", "ONGC.NS", "POWERGRID.NS", "COALINDIA.NS",   
  "ADANIPOWER.NS", "IOC.NS", "ADANIGREEN.NS", "BPCL.NS", "TATAPOWER.NS",    
  "GAIL.NS", "SIEMENS.NS", "ABB.NS", "CGPOWER.NS", "ADANIENSOL.NS",    
  "JSWENERGY.NS", "HITACHI.NS", "HINDPETRO.NS", "SUZLON.NS", "NHPC.NS",        
  "BHEL.NS", "GEPOWER.NS", "OIL.NS", "TORNTPOWER.NS", "ATGL.NS", "PETRONET.NS",       "THERMAX.NS", "SJVN.NS", "NLCINDIA.NS", "GUJGASLTD.NS", "IGL.NS","AEGISCHEM.NS",   "INOXWIND.NS", "CESC.NS", "CASTROLIND.NS", "RPOWER.NS", "GSPL.NS","TRITURBINE.NS", "JPPOWER.NS", "MGL.NS")

```

### Getting start date and end date for fetching the returns in the range

```{r}
# TAKING THE INPUTS
startdate<-"2021-01-01"
enddate<- Sys.Date()
#TICKER INPUT OF SYMBOL
tickers<- bank
```

### Function to import the data

```{r}
# CREATING FUNCTION TO IMPORT PRICES AND RETURNS DATA
get_data <- function(tickers, start, end) {
  price_list <- list()
  return_list <- list()
  for (ticker in tickers) {
    tryCatch({
      data <- getSymbols(ticker, from = start, to = end, auto.assign = FALSE)
      adj_price <- Ad(data)
      daily_ret <- dailyReturn(adj_price, type = "arithmetic")
      clean_name <- sub("\\..*$", "", ticker)
      colnames(adj_price) <- clean_name
      colnames(daily_ret) <- clean_name
      price_list[[clean_name]] <- adj_price
      return_list[[clean_name]] <- daily_ret
    }, error = function(e) {
      cat("Error with", ticker, ":", e$message, "\n")
    })
  }
  prices <- do.call(merge, price_list)
  returns <- do.call(merge, return_list)
  return(list(prices = prices, returns = returns))
}
```

### Getting the dataframe of prices and returns

```{r}
#EXTRACTING THE DATA
stock_data <- get_data(tickers, startdate, enddate)
price_df <- na.omit(data.frame(date = index(stock_data$prices), stock_data$prices))
return_df <- na.omit(data.frame(date = index(stock_data$returns), stock_data$returns))
```

### Applying Principal component analysis

```{r}
# APPLYING PRINCIPAL COMPONENT ANALYSIS

pca <- PCA(return_df[-1,-1], scale.unit = TRUE, graph = FALSE, 
           ncp = ncol(return_df))

#getting the eigenvalue matrix
eigenvalues <- pca$eig[, 1]

#getting the variane explained by each components
variance_explained <- pca$eig[, 2]

#getting the cumulative variance explained by each component
cumulative_variance <- pca$eig[, 3]

#creating the dataframe of eigenvalues, variance explained and cumulative variance 
eigenvalues_df <- data.frame(
  PC = factor(paste0("PC", seq_along(eigenvalues)), levels = paste0("PC", seq_along(eigenvalues))),
  Eigenvalue = eigenvalues,
  VarianceExplained = variance_explained,
  CumulativeVariance = cumulative_variance
)
```

### Scree plot eigenvalues of each component

```{r}
#| warning: false
eig_plot <- ggplot(eigenvalues_df, aes(x = PC, y = Eigenvalue, group = 1)) +
  geom_bar(stat = "identity", fill = "skyblue", alpha = 0.8) +
  geom_line(color = "blue", size = 1.2) +
  geom_point(color = "red", size = 2) +
  labs(title = "Scree Plot - Eigenvalues from PCA",
       x = "Principal Components",
       y = "Eigenvalue") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 45, hjust = 1))
```

### Plot of variance explained by each component

```{r}
var_plot<- ggplot(eigenvalues_df, aes(x = PC)) +
geom_bar(aes(y = VarianceExplained),stat ="identity",fill ="skyblue",alpha = 0.6) +
labs(title = "Variance Explained by Component",
     x = "Principal Components",
     y = "Percentage (%)") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5),axis.text.x = element_text(angle = 45, hjust = 1))
```

### Visualize the plots

```{r}
pca_plots <- eig_plot / var_plot
pca_plots
```

### PCA results dataframe

```{r}
eigenvalues_df
```

### Function to get the plot of eigenvectors of each component

```{r}
#FUNCTION TO GET PLOTS OF EIGENVECTORS
eigvec_plot <- function(pca, n){
  eigvec <- as.data.frame(pca$var$coord)
  my_colors <- rainbow(length(eigvec$Dim.1))
  plot<- barplot(eigvec[,n], col = my_colors, 
                          main = paste("WEIGTHS OF PRINCIPAL COMPONENT",n,sep = " "),
                          ylab = "Weights", las = 2,names.arg = rownames(eigvec))
  
  return(plot)
}
```

### Function to get plot of rolling variance of the ith Principal comonent

```{r}
#FUNCTION TO GET ROLLING EXPLAINED VARIANCE PLOT OF iTH PC
pcvar_plot <- function(df, n, t) {
  df_dates <- as.Date(df[[1]])
  df_returns <- df[-1, -1]
  d1 <- data.frame(Date = as.Date(character()), ExpVar = numeric())
  for (i in 1:(nrow(df_returns) - t)) {
    j <- i + t
    k <- round((i + j) / 2) 
    window_data <- df_returns[i:j, ]
    pca_temp <- prcomp(window_data, center = TRUE, scale. = TRUE)
    exp_var <- pca_temp$sdev[n]^2 / sum(pca_temp$sdev^2)
    d1 <- rbind(d1, data.frame(Date = df_dates[k], ExpVar = exp_var))
  }
  ggplot(d1, aes(x = Date, y = ExpVar)) +
    geom_line(color = "darkblue", size = 1) +
    labs(title = paste("Rolling Explained Variance of PC", n),
         x = "Date", y = "Explained Variance") +
    theme_minimal() + theme(plot.title = element_text(hjust = 0.5),
          axis.text.x = element_text(angle = 45, hjust = 1))
}

```

### Visualizing the eigenvector loadings

```{r}
#| fig-height: 8
#| fig-width: 10
p1 <-   eigvec_plot(pca, 1) 
p2 <-   eigvec_plot(pca, 2)
p3 <-   eigvec_plot(pca, 3)
p4 <-   eigvec_plot(pca, 4)
p5 <-   eigvec_plot(pca, 5)
p6 <-   eigvec_plot(pca, 6)
```

### Rolling variance explained plot

```{r}
pcvar_plot(return_df,1, 120)
```

### Added variable plots of regressing returns on top PC scores

```{r}
library(MASS)
library(car)

names <- colnames(return_df[, -1])
components <- as.data.frame(pca$ind$coord)[, 1:4]

avplots_list <- list()
coeff_df <- data.frame()

for (i in names) {
  reg_data <- cbind(return_df[-1, i, drop = FALSE], components)
  colnames(reg_data)[1] <- "target"

  po <- rlm(target ~ ., data = reg_data)

  # Storing AV plots
  avPlots(po, main = paste("AV Plots:", i))
  avplots_list[[i]] <- recordPlot()

  # Getting coefficients
  coefs <- coef(po)
  coeff_row <- as.data.frame(t(coefs))
  coeff_row$stock <- i

  # Binding row to main dataframe
  coeff_df <- rbind(coeff_df, coeff_row)
}


```

### Dataframe of regression coefficients

```{r}
coeff_df
```

### Calculating market return and 21 days rolling volatility

```{r}
# Store original row count
n_original <- nrow(return_df)

# Columns without 'date'
stock_cols <- setdiff(names(return_df), "date")

# Market return = mean of all stocks
return_df$market <- rowMeans(return_df[stock_cols], na.rm = TRUE)

# Rolling 21-day market volatility
return_df$rolling_vol <- rollapply(return_df$market, 21, sd, na.rm = TRUE, 
                                   fill = NA, align = "right")


# Fill NA rolling vol, remove incomplete rows
return_df$rolling_vol <- na.locf(return_df$rolling_vol, na.rm = FALSE)
return_df <- na.omit(return_df)

# Report removed rows
cat("Removed", n_original - nrow(return_df), "rows with missing values\n")

```

### Applying PCA and getting the scores

```{r}

#Getting names of stocks
stock_cols <- names(return_df)[!names(return_df) %in% 
                                 c("date", "market", "rolling_vol")]

#getting dataframe of stock returns only
stock_returns <- return_df[, stock_cols]
#scaling the stock returns
scaled_returns <- scale(stock_returns)
#PCA on stock returns
pca_result <- PCA(scaled_returns, graph = FALSE, ncp = 10)
#getting the eigenvalues of each components
eigenvalues <- pca_result$eig
#selecting eigenvalues greater than 1 (kaiser criteriion)
n_components <- sum(eigenvalues[,1] > 1) 
#putting lower and upper bound on components chosen
n_components <- min(max(n_components, 4), 6)
#getting the scores of each component
pc_scores <- as.data.frame(pca_result$ind$coord[, 1:n_components])
colnames(pc_scores) <- paste0("PC", 1:n_components)
return_df <- cbind(return_df, pc_scores)
pc_data <- return_df[grep("^PC\\d+$", names(return_df))]
```

### Fitting Bayesian GMM with Dirichlet prior

```{r}

fit_regime_model_bayes <- function(pc_data,
                                   G_range = 1:9,
                                   model_names = c("EII","VII","EEI","VEI","EVI","VVI","EEE","EEV","VEV","VVV"),
                                   alpha = seq(0.01, 1, 0.05),
                                   auto_select = TRUE) {
  require(mclust)
  set.seed(123)

  cat("Running Bayesian-like GMM with Dirichlet shrinkage priors (mclust)â€¦\n")

  best_bic <- -Inf
  best_model <- NULL
  best_alpha <- NULL

  for (a in alpha) {
    gmm_candidate <- Mclust(
      pc_data,
      G = G_range,
      modelNames = model_names,
      prior = priorControl(functionName = "defaultPrior",
                           shrinkage = a),   # Dirichlet-style shrinkage weight
      verbose = FALSE
    )

    if (!is.null(gmm_candidate) && !is.na(gmm_candidate$bic) && gmm_candidate$bic > best_bic) {
      best_model <- gmm_candidate
      best_bic <- gmm_candidate$bic
      best_alpha <- a
    }
  }

  if (is.null(best_model)) stop("Model did not converge. Check data scaling or G_range.")

  cat("\nOptimal model found:\n")
  cat("  G =", best_model$G, "\n")
  cat("  Covariance =", best_model$modelName, "\n")
  cat("  Shrinkage =", round(best_alpha, 3), "\n")
  cat("  BIC =", round(best_bic, 2), "\n")

  return(list(model = best_model,
              alpha = best_alpha,
              G = best_model$G,
              modelName = best_model$modelName,
              BIC = best_bic))
}


assign_regimes_bayes <- function(model_object, return_df) {
  return_df$regime <- model_object$model$classification
  return_df$regime_prob <- apply(model_object$model$z, 1, max)

  regime_stats <- return_df %>%
    group_by(regime) %>%
    summarise(n_obs = n(),
              mean_return = mean(market, na.rm = TRUE),
              vol = sd(market, na.rm = TRUE),
              sharpe = mean_return / vol)

  cat("\nRegime characteristics:\n")
  print(regime_stats)
  return(return_df)
}


bayes_model <- fit_regime_model_bayes(pc_data, G_range = 2:6)
return_df  <- assign_regimes_bayes(bayes_model, return_df)


```

### Plots of market returns across regimes

```{r}

plot1 <- ggplot(return_df, aes(x = date, y = market, color = factor(regime))) +
  geom_line() +
  labs(title = "Market Return with Regimes", color = "Regime") +
  theme_minimal()

plot2<- ggplot(return_df, aes(market, fill = factor(regime))) +
  geom_histogram(alpha = 0.3, bins = 30) +
  facet_wrap(~ regime, scales = "free_y") +
  labs(title = "Market Return by Regime", fill = "Regime") +
  theme_minimal()

wrap_plots(list(plot1, plot2), ncol=1)
```

### Boxplots of return and volatility across regimes

```{r}
# Boxplots for volatility and dispersion
 ggplot(return_df, aes(x = factor(regime), y = market)) +
  geom_boxplot() + labs(title="Market Return by Regime", x="Regime", y="Market Return")

 ggplot(return_df, aes(x = factor(regime), y = rolling_vol)) +
  geom_boxplot() + labs(title="21-day Volatility by Regime", x="Regime", y="Volatility")

```

### Getting Markov Transition matrix

```{r}
# Transition matrix calculation
transition_counts <- table(
  from = head(return_df$regime, -1),
  to   = tail(return_df$regime, -1)
)

transition_matrix <- prop.table(transition_counts, margin = 1)
print(transition_matrix)

# Visualize transitions as heatmap
transition_df <- as.data.frame(as.table(transition_matrix))
colnames(transition_df) <- c("From", "To", "Probability")

ggplot(transition_df, aes(x = From, y = To, fill = Probability)) +
  geom_tile(color = "white") +
  geom_text(aes(label = round(Probability, 2)), color = "black") +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Regime Transition Probability Matrix",
       x = "From Regime", y = "To Regime") +
  theme_minimal()
```
